/*! /file examples.h
  General header file for all of the protocol-level implementations.
  
  Also contains documentation for namespaces and structs.
 */

/*! \namespace SMImp
  Smart Meter Implementation, namespace for any classes which strictly implement the protocol.
 */

/*! \namespace smart3p
  Namespace for the upper-level simulation classes.
 */

//Class references for Crypto++: http://www.cryptopp.com/docs/ref/index.html
#ifndef __SMIMP_EXAMPLES_H_
#define __SMIMP_EXAMPLES_H_

#include <iostream>
#include <stdlib.h> //atoi, itoa
#include <math.h>   //pow
#include <bitset>   //bitset
//#include <chrono>   //C++11 timing

#include "list.h"

//http://www.cryptopp.com/docs/ref/nbtheory_8h.html
#include "nbtheory.h"
#include "osrng.h"
#include "integer.h"
#include "hmac.h"
#include "sha.h"
#include "gfpcrypt.h"


#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1
#include "md2.h"

namespace SMImp {

using namespace CryptoPP;

//! Holds the elements for key generation
struct MasterKey
{
    Integer p;
    Integer q;
    Integer g;
    Integer x;
};

//! A key reprisentation
struct Key
{
    //! Piece generated by the SMImp::Requester
    Integer piece;
    //! Partial key generated by the SMImp::UtilityCompany
    Integer partial;
};

//! Public and private pair of keys
struct KeyPair
{
    //! Private key.
    Key priv;
    //! Public key.
    Key pub;
};

//! Payload containing all the required parameters for key generation.
struct Payload
{
    MasterKey params;
    //! Private partial key.
    Integer priv;
    //! Public partial key.
    Integer pub;
};

//! HMAC signed payload with encrypted elements
struct HMACPayload
{
    //! Total length of the message.
    /*!
      Since fragmentation is possible, it's important to know the totaly length of the overall message being sent.
    */
    Integer messageLength;
    //! Generated HMAC for verification.
    Integer hmac;
    //! Part 1 of the encrypted message.
    Integer c1;
    //! Part 2 of the encrypted message.
    Integer c2;
    //! ID of the originating Requester.
    Integer id;
    //! Timestamp
    Integer timeStamp;
    //! Shared secret, often unused.
    Integer r;
};

//! HMACPayload with a destination ID.
struct Packet
{
    Integer dest;
    HMACPayload pl;
};

class UtilityCompany;
class TrustedParty;
class SmartMeter;

//! Required for selecting primes
/*!
  \sa SMImp::UtilityCompany::generateKey()
*/
class pSelector : public PrimeSelector
{
private:
    Integer p;
    
public:
    pSelector()
    {
	p=0;
    }
    ~pSelector()
    {}

    void setP(Integer newp)
    {
	p = newp;
    }
    
    bool IsAcceptable(const Integer &candidate) const
    {
	return IsPrime(candidate) ; //First run through, since p will not be set yet
    }
};

//! Cryptopp::Integer to byte array
static byte* itob(Integer i)
{
    byte* output = new byte[i.ByteCount()];
    for (unsigned int j=0;j<i.ByteCount();j++) output[j] = i.GetByte(j);
    return output;
}

//! byte array to Cryptopp::Integer
static Integer btoi(byte* b, int length)
{
    Integer output = 0;
    for (unsigned int i=0;i<length;i++) output.SetByte(i,int(b[i]));
    return output;
}

/*!
  Meant to be used as a general hashing algorithm. Takes in any sized input and outputs an Integer of size equal to the digest size
*/
static Integer generateHash(HashTransformation* hash, byte* input, int length)
{
    hash->Restart();
    hash->Update(input,length);

    byte* outputString = new byte[hash->DigestSize()];
    hash->Final(outputString);

    Integer output = 0;

    for (unsigned int i=0;i<hash->DigestSize();i++)
    {
	output.SetByte(i,outputString[i]);
    }

    return output;    
}

//! Concatonate two strings (stored as CryptoPP::Integer) and hash them.
static Integer concatAndHash(HashTransformation* hash, Integer one, Integer two)
{
    byte* input = new byte[one.ByteCount() + two.ByteCount()];
    for (unsigned int i=0;i<(one.ByteCount() + two.ByteCount());i++) input[i] = 0;
        
    for (unsigned int i=0;i<one.ByteCount();i++) input[i] = one.GetByte(i);
    for (unsigned int i=0;i<two.ByteCount();i++) input[i+one.ByteCount()] = two.GetByte(i);
    
    return generateHash(hash, input, one.ByteCount()+two.ByteCount());
}

//! Hash a single CrptoPP::Integer
static Integer hashInteger(HashTransformation* hash, Integer i)
{
    return generateHash(hash,itob(i),i.ByteCount());
}

//! Helper function for HMAC generation.
/*!
  \param key General key for use with HMAC generation. Can be shared-secret, timestamp, etc.
  \param pl HMACPayload to be used for input.
  \return Returns CryptoPP::Integer of the HMAC
*/
static Integer generateHMAC(Integer key, HMACPayload pl)
{
    //verify HMAC
    HMAC<Weak::MD2>* hmac = new HMAC<Weak::MD2>(itob(key),key.ByteCount());
    hmac->Update(itob(pl.c1),pl.c1.ByteCount());
    hmac->Update(itob(pl.c2),pl.c2.ByteCount());
    hmac->Update(itob(pl.id),pl.id.ByteCount());
    hmac->Update(itob(pl.timeStamp),pl.timeStamp.ByteCount());

    int length = hmac->DigestSize();

    byte* digest = new byte[length];
    hmac->Final(digest);

    Integer output = Integer(digest,hmac->DigestSize());
    
    return output;
}

};

#endif
